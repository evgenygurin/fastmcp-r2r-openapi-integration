# R2R â†” FastMCP: ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¸ ÑĞ¸Ğ¼Ğ±Ğ¸Ğ¾Ğ·Ğ°

**Comprehensive analysis of integration points, transition paths, and symbiotic patterns**

---

## ğŸ“‘ ĞĞ³Ğ»Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ

1. [Ğ’Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ](#-Ğ²Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ)
2. [ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ğ°Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ](#-Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ğ°Ñ-ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ)
3. [Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµÑĞµÑ‡ĞµĞ½Ğ¸Ñ](#-Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ-Ğ¿ĞµÑ€ĞµÑĞµÑ‡ĞµĞ½Ğ¸Ñ)
4. [Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ°](#-Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸-Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ°)
5. [Ğ¡Ğ¸Ğ¼Ğ±Ğ¸Ğ¾Ğ·: Ğ›ÑƒÑ‡ÑˆĞ¸Ğµ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸](#-ÑĞ¸Ğ¼Ğ±Ğ¸Ğ¾Ğ·-Ğ»ÑƒÑ‡ÑˆĞ¸Ğµ-Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸)
6. [Ğ—Ğ°ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ](#-Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ-Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ)
7. [Production Patterns](#-production-patterns)
8. [ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñ‹](#-Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ-Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñ‹)
9. [Ğ¡Ñ€Ğ°Ğ²Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·](#-ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹-Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·)

---

## ğŸ¯ Ğ’Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ

**R2R (RAG to Riches)** Ğ¸ **FastMCP** - Ğ´Ğ²Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ½Ğ¾Ğ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ·ÑƒÑÑ‚ Ğ¼Ğ¾Ñ‰Ğ½ÑƒÑ Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ñƒ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ production-ready RAG-Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¹.

### ĞšĞ»ÑÑ‡ĞµĞ²Ğ¾Ğ¹ Ğ¿Ñ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   LLM (Claude, GPT)                  â”‚
â”‚                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ MCP Protocol
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   FastMCP Server                     â”‚  â† Presentation Layer
â”‚  (Tools, Resources, Prompts)                         â”‚     (LLM Interface)
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Business Logic Layer                           â”‚ â”‚
â”‚  â”‚ - Pipelines (composition)                      â”‚ â”‚
â”‚  â”‚ - Middleware (auth, logging, caching)          â”‚ â”‚
â”‚  â”‚ - Context (dependency injection)               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ HTTP/REST API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    R2R Engine                        â”‚  â† Data Access Layer
â”‚  (Documents, Search, RAG, Knowledge Graph)           â”‚     (RAG Backend)
â”‚                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Storage Layer                                  â”‚ â”‚
â”‚  â”‚ - PostgreSQL (pgvector)                        â”‚ â”‚
â”‚  â”‚ - Neo4j (knowledge graph)                      â”‚ â”‚
â”‚  â”‚ - Redis (caching)                              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Separation of Concerns:**
- **FastMCP**: Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ LLM (MCP ÑĞµÑ€Ğ²ĞµÑ€)
- **R2R**: Ğ”Ğ²Ğ¸Ğ¶Ğ¾Ğº Ğ´Ğ»Ñ RAG (Backend ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°)

---

## ğŸ—ï¸ ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ğ°Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ

### 1. Ğ§ĞµÑ‚Ñ‹Ñ€ĞµÑ…ÑĞ»Ğ¾Ğ¹Ğ½Ğ°Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Presentation Layer (FastMCP)           â”‚
â”‚  - Tools (@mcp.tool)                    â”‚
â”‚  - Resources (@mcp.resource)            â”‚
â”‚  - Prompts (@mcp.prompt)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Business Logic Layer (FastMCP)         â”‚
â”‚  - Pipelines (composition)              â”‚
â”‚  - Middleware (auth, logging)           â”‚
â”‚  - Context (dependency injection)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Data Access Layer (FastMCP â†’ R2R)      â”‚
â”‚  - httpx.AsyncClient                    â”‚
â”‚  - DynamicBearerAuth                    â”‚
â”‚  - OpenAPI auto-generation              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  RAG Backend Layer (R2R)                â”‚
â”‚  - Documents (ingestion, search)        â”‚
â”‚  - Knowledge Graph (entities, relations)â”‚
â”‚  - Agent (reasoning, tools)             â”‚
â”‚  - Collections (organization)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Ğ¡ĞµĞ¼Ğ°Ğ½Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (OpenAPI â†’ MCP)

FastMCP Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ĞºĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ R2R OpenAPI ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ² MCP ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ Ğ¿Ğ¾ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¼ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°Ğ¼:

```python
# Route mapping order (FIRST MATCH WINS)
_route_maps = [
    # GET Ñ path parameters â†’ RESOURCE_TEMPLATE
    RouteMap(
        methods=["GET"],
        pattern=r"^/v3/.*\{.*\}.*$",  # e.g., /v3/documents/{id}
        mcp_type=MCPType.RESOURCE_TEMPLATE,
    ),

    # GET Ğ±ĞµĞ· parameters â†’ RESOURCE
    RouteMap(
        methods=["GET"],
        pattern=r"^/v3/.*$",           # e.g., /v3/documents
        mcp_type=MCPType.RESOURCE,
    ),

    # POST/PUT/PATCH/DELETE â†’ TOOL
    RouteMap(
        methods=["POST", "PUT", "PATCH", "DELETE"],
        pattern=r".*",                 # Any endpoint
        mcp_type=MCPType.TOOL,
    ),
]
```

**ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿:**
- **Read operations (GET)** â†’ Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ LLM
- **Write operations (POST/PUT/DELETE)** â†’ Ğ”ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ LLM

### 3. DynamicBearerAuth: ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½ Ğ´Ğ»Ñ serverless

**ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°:** FastMCP Cloud Ğ¸ serverless Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ Ğ¸Ğ½Ğ¶ĞµĞºÑ‚ÑÑ‚ env vars ĞŸĞĞ¡Ğ›Ğ• Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ° Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹.

**Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ:** Request-time authentication (Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ API key Ğ¿Ñ€Ğ¸ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞµ, ĞĞ• Ğ¿Ñ€Ğ¸ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğµ).

```python
class DynamicBearerAuth(httpx.Auth):
    """Auth handler that reads API key from environment at request time.

    CRITICAL for FastMCP Cloud compatibility:
    - Reads R2R_API_KEY DURING request execution
    - NOT at module import time
    - Ensures auth works in serverless environments
    """

    def auth_flow(self, request: httpx.Request):
        """Inject Bearer token at request time."""
        api_key = os.getenv("R2R_API_KEY", "")
        if api_key:
            request.headers["Authorization"] = f"Bearer {api_key}"
        yield request

# Global async client with dynamic auth
_client = httpx.AsyncClient(
    base_url=os.getenv("R2R_BASE_URL", "http://localhost:7272"),
    auth=DynamicBearerAuth(),  # â† Authentication Ğ½Ğ° request-time!
    timeout=30.0,
)
```

**ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ²Ğ°Ğ¶Ğ½Ğ¾:**
1. **Serverless compatibility** - env vars Ğ¸Ğ½Ğ¶ĞµĞºÑ‚ÑÑ‚ÑÑ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ°
2. **Security** - API key Ğ½Ğ¸ĞºĞ¾Ğ³Ğ´Ğ° Ğ½Ğµ Ñ…Ğ°Ñ€Ğ´ĞºĞ¾Ğ´Ğ¸Ñ‚ÑÑ
3. **Flexibility** - Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¼ĞµĞ½ÑÑ‚ÑŒ API key Ğ±ĞµĞ· Ğ¿ĞµÑ€ĞµĞ·Ğ°Ğ¿ÑƒÑĞºĞ° ÑĞµÑ€Ğ²ĞµÑ€Ğ°

---

## ğŸ”— Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµÑĞµÑ‡ĞµĞ½Ğ¸Ñ

### ĞœĞ°Ñ‚Ñ€Ğ¸Ñ†Ğ° Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸

| Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ | R2R | FastMCP | ĞšÑ‚Ğ¾ Ğ²Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ†? |
|---------|-----|---------|---------------|
| **Document Ingestion** | âœ… Core | â¡ï¸ Proxy | R2R |
| **Vector Search** | âœ… Core | â¡ï¸ Proxy | R2R |
| **Knowledge Graph** | âœ… Core | â¡ï¸ Proxy | R2R |
| **RAG Generation** | âœ… Core | â¡ï¸ Proxy | R2R |
| **Agent (Reasoning)** | âœ… Core | â¡ï¸ Proxy | R2R |
| **MCP Protocol** | âŒ | âœ… Core | FastMCP |
| **LLM Interface (Tools/Resources)** | âŒ | âœ… Core | FastMCP |
| **Middleware (Logging, Auth)** | âŒ | âœ… Core | FastMCP |
| **Pipeline Composition** | âŒ | âœ… Core | FastMCP |
| **Context Dependency Injection** | âŒ | âœ… Core | FastMCP |
| **Authentication (JWT/OAuth)** | âœ… Built-in | âœ… Built-in | Both (Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ ÑƒÑ€Ğ¾Ğ²Ğ½Ğ¸) |
| **HTTP Transport** | âœ… Server | âœ… Client | Both |
| **Caching** | âœ… Built-in | âœ… Middleware | Both (Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ ÑĞ»Ğ¾Ğ¸) |

### Ğ’Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼Ğ¾ÑÑ‚ÑŒ

**R2R Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚:**
- ğŸ—‚ï¸ Document management (upload, metadata, deletion)
- ğŸ” Advanced search (semantic, fulltext, hybrid, graph)
- ğŸ§  RAG with streaming generation
- ğŸ•¸ï¸ Knowledge Graph (entities, relationships, communities)
- ğŸ¤– Agent with reasoning (research mode, tool calling)
- ğŸ“š Collections (multi-tenancy, access control)
- ğŸ“Š Analytics (usage, performance)

**FastMCP Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚:**
- ğŸ¨ Presentation Layer Ğ´Ğ»Ñ LLM (Tools, Resources, Prompts)
- ğŸ”„ Pipeline composition (chainable async operations)
- ğŸ›¡ï¸ Middleware (auth, logging, caching, rate limiting)
- ğŸ“¦ Context (dependency injection)
- ğŸ§ª Testing framework (async-friendly)
- ğŸš€ Deployment (stdio, HTTP, SSE, FastMCP Cloud)
- ğŸ”§ OpenAPI auto-generation (REST API â†’ MCP)

**Ğ”ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸:**
- ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ (Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ ÑƒÑ€Ğ¾Ğ²Ğ½Ğ¸ Ğ°Ğ±ÑÑ‚Ñ€Ğ°ĞºÑ†Ğ¸Ğ¸)
- ĞĞ±Ğ° Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑÑÑ‚ HTTP ÑĞµÑ€Ğ²ĞµÑ€, Ğ½Ğ¾ Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ†ĞµĞ»ĞµĞ¹:
  - R2R: REST API Ğ´Ğ»Ñ RAG Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹
  - FastMCP: MCP ÑĞµÑ€Ğ²ĞµÑ€ Ğ´Ğ»Ñ LLM Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸

---

## ğŸ”„ Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ°

### 1. ĞÑ‚ Ñ‡Ğ¸ÑÑ‚Ğ¾Ğ³Ğ¾ R2R Ğº R2R + FastMCP

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹:** Ğ£ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ R2R backend, Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ MCP Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ LLM.

**Ğ¨Ğ°Ğ³Ğ¸:**

1. **Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ FastMCP ÑĞµÑ€Ğ²ĞµÑ€ Ñ OpenAPI auto-generation:**

```python
from fastmcp import FastMCP

# Auto-generate MCP components from R2R OpenAPI
mcp = FastMCP.from_openapi(
    name="R2R MCP Server",
    spec_url="http://localhost:7272/openapi.json",
    base_url="http://localhost:7272",
    route_maps=[
        # GET Ñ params â†’ RESOURCE_TEMPLATE
        RouteMap(
            methods=["GET"],
            pattern=r"^/v3/.*\{.*\}.*$",
            mcp_type=MCPType.RESOURCE_TEMPLATE,
        ),
        # GET Ğ±ĞµĞ· params â†’ RESOURCE
        RouteMap(
            methods=["GET"],
            pattern=r"^/v3/.*$",
            mcp_type=MCPType.RESOURCE,
        ),
        # POST/PUT/DELETE â†’ TOOL
        RouteMap(
            methods=["POST", "PUT", "PATCH", "DELETE"],
            pattern=r".*",
            mcp_type=MCPType.TOOL,
        ),
    ],
    auth=DynamicBearerAuth(),
)
```

2. **Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ ĞºĞ°ÑÑ‚Ğ¾Ğ¼Ğ½Ñ‹Ğµ enhanced tools (Ğ¾Ğ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾):**

```python
@mcp.tool(
    description="Enhanced search with progress and AI analysis",
    tags={"search", "ai"}
)
async def enhanced_search(
    query: str,
    limit: int = 10,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Search with progress reporting and LLM analysis."""
    if ctx:
        await ctx.report_progress(0, 100, "Searching R2R...")

    # Ğ’Ñ‹Ğ·Ğ¾Ğ² R2R API
    response = await _client.post(
        "/v3/retrieval/search",
        json={"query": query, "limit": limit}
    )

    if ctx:
        await ctx.report_progress(50, 100, "Analyzing results...")

        # AI analysis Ñ ctx.sample
        analysis = await ctx.sample(
            prompt=f"Analyze these search results: {response.json()}"
        )

        await ctx.report_progress(100, 100, "Completed")

    return {
        "results": response.json(),
        "analysis": analysis.text if ctx else None
    }
```

3. **Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚Ğµ ÑĞµÑ€Ğ²ĞµÑ€:**

```bash
# stdio Ğ´Ğ»Ñ Claude Desktop
python -m src.server

# HTTP Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸
python -m src.server http 8000
```

**Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚:** R2R backend Ğ¾ÑÑ‚Ğ°ĞµÑ‚ÑÑ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹, FastMCP Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ MCP Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ.

---

### 2. ĞœĞ¾Ğ´ÑƒĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´ (Ğ¿Ğ¾ÑÑ‚Ğ°Ğ¿Ğ½Ğ¾Ğµ Ğ²Ğ½ĞµĞ´Ñ€ĞµĞ½Ğ¸Ğµ)

**Phase 1: Basic MCP Integration**
```python
# Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ auto-generated components (Resources + Tools)
mcp = FastMCP.from_openapi(
    spec_url="http://localhost:7272/openapi.json",
    # ... route maps
)
```

**Phase 2: Add Custom Tools**
```python
# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ enhanced tools Ñ Context
@mcp.tool()
async def custom_tool(param: str, ctx: Context) -> dict:
    # Custom logic + R2R calls
    ...
```

**Phase 3: Add Middleware**
```python
# Middleware Ğ´Ğ»Ñ logging, caching, rate limiting
from fastmcp import Middleware

class LoggingMiddleware(Middleware):
    async def on_request(self, ctx):
        logger.info(f"Request: {ctx.method} {ctx.path}")
        return await super().on_request(ctx)

mcp.add_middleware(LoggingMiddleware)
```

**Phase 4: Add Pipelines**
```python
# Pipeline composition Ğ´Ğ»Ñ complex workflows
from src.pipelines import Pipeline

@mcp.tool()
async def research_pipeline(query: str, ctx: Context) -> dict:
    pipeline = Pipeline(ctx)
    return await (
        pipeline
        .add_step("search", pipeline_search_and_analyze, query=query)
        .add_step("analyze", pipeline_llm_analyze)
        .add_step("summarize", pipeline_llm_summarize)
        .execute()
    )
```

**ĞŸÑ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ° Ğ¿Ğ¾ÑÑ‚Ğ°Ğ¿Ğ½Ğ¾Ğ³Ğ¾ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ°:**
- âœ… ĞĞ¸Ğ·ĞºĞ¸Ğ¹ Ñ€Ğ¸ÑĞº (ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ phase Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼)
- âœ… Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¾Ñ‚Ğ´Ğ°Ñ‡Ğ° (Phase 1 Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğ·Ğ° 30 Ğ¼Ğ¸Ğ½ÑƒÑ‚)
- âœ… ĞŸĞ¾ÑÑ‚ĞµĞ¿ĞµĞ½Ğ½Ğ¾Ğµ Ğ¾Ğ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹
- âœ… ĞŸÑ€Ğ¾ÑÑ‚Ğ°Ñ Ğ¾Ñ‚ĞºĞ°Ñ‚ĞºĞ° (Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğ½Ğ° Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ÑƒÑ phase)

---

### 3. Migration Path: REST API â†’ MCP

**Ğ”Ğ¾ (Ğ¿Ñ€ÑĞ¼Ñ‹Ğµ REST Ğ²Ñ‹Ğ·Ğ¾Ğ²Ñ‹):**
```python
# ĞšĞ»Ğ¸ĞµĞ½Ñ‚ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ R2R REST API
import requests

def search(query: str) -> dict:
    response = requests.post(
        "http://localhost:7272/v3/retrieval/search",
        json={"query": query},
        headers={"Authorization": f"Bearer {API_KEY}"}
    )
    return response.json()
```

**ĞŸĞ¾ÑĞ»Ğµ (Ñ‡ĞµÑ€ĞµĞ· MCP):**
```python
# LLM Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ MCP tool, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾ĞºÑĞ¸Ñ€ÑƒĞµÑ‚ Ğº R2R
from fastmcp import Context

@mcp.tool()
async def search(
    query: str,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Search R2R knowledge base."""
    if ctx:
        await ctx.info(f"Searching: {query}")

    response = await _client.post(
        "/v3/retrieval/search",
        json={"query": query}
    )

    return response.json()
```

**ĞŸÑ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ° MCP Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ°:**
- ğŸ¯ LLM Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ tools Ğ°Ğ²Ñ‚Ğ¾Ğ½Ğ¾Ğ¼Ğ½Ğ¾
- ğŸ“Š Progress reporting (ctx.report_progress)
- ğŸ” Context logging (ctx.info/debug/error)
- ğŸ§  LLM sampling (ctx.sample) Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ tool
- ğŸ”„ Pipeline composition (chainable operations)

---

## ğŸ¤ Ğ¡Ğ¸Ğ¼Ğ±Ğ¸Ğ¾Ğ·: Ğ›ÑƒÑ‡ÑˆĞ¸Ğµ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸

### 1. FastMCP ĞºĞ°Ğº MCP Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ, R2R ĞºĞ°Ğº RAG backend

**Ğ˜Ğ´ĞµĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°:**

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              LLM (Claude)                â”‚
â”‚                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ MCP Protocol
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          FastMCP Server                  â”‚
â”‚                                          â”‚
â”‚  Tools:                                  â”‚
â”‚  - search(query)         â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  - rag(question)          â”€â”€â”€â”€â”€â” â”‚       â”‚
â”‚  - agent(message)          â”€â”€â”€â”â”‚ â”‚       â”‚
â”‚  - upload_document(file)    â”€â”â”‚â”‚ â”‚       â”‚
â”‚                               â”‚â”‚â”‚ â”‚       â”‚
â”‚  Resources:                   â”‚â”‚â”‚ â”‚       â”‚
â”‚  - r2r://documents/{id}    â”€â” â”‚â”‚â”‚ â”‚       â”‚
â”‚  - r2r://collections       â”€â”¼â”â”‚â”‚â”‚ â”‚       â”‚
â”‚                             â”‚â”‚â”‚â”‚â”‚â”‚ â”‚       â”‚
â”‚  Pipelines:                 â”‚â”‚â”‚â”‚â”‚â”‚ â”‚       â”‚
â”‚  - research_pipeline()      â”‚â”‚â”‚â”‚â”‚â”‚ â”‚       â”‚
â”‚  - comparative_analysis()   â”‚â”‚â”‚â”‚â”‚â”‚ â”‚       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”¼â”¼â”¼â”¼â”¼â”€â”˜
               â”‚              â”‚â”‚â”‚â”‚â”‚â”‚
               â”‚ HTTP/REST    â”‚â”‚â”‚â”‚â”‚â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â–¼â–¼â–¼â–¼â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              R2R Backend                    â”‚
â”‚                                             â”‚
â”‚  POST /v3/retrieval/search  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  POST /v3/retrieval/rag     â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  POST /v3/retrieval/agent   â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”‚
â”‚  POST /v3/documents         â—„â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”‚ â”‚
â”‚  GET  /v3/documents/{id}    â—„â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”‚ â”‚ â”‚
â”‚  GET  /v3/collections       â—„â”€â”€â”€â”€â”¤ â”‚ â”‚ â”‚ â”‚ â”‚
â”‚                                  â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
â”‚  Storage:                        â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
â”‚  - PostgreSQL (pgvector)         â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
â”‚  - Neo4j (knowledge graph)       â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
â”‚  - Redis (caching)               â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”´â”€â”´â”€â”´â”€â”´â”€â”˜
```

### 2. Middleware Ğ´Ğ»Ñ cross-cutting concerns

**Logging Middleware:**
```python
from fastmcp import Middleware

class LoggingMiddleware(Middleware):
    async def on_call_tool(self, ctx, tool_name: str, arguments: dict):
        logger.info(f"Tool: {tool_name}, Args: {arguments}")
        start_time = time.time()

        result = await super().on_call_tool(ctx, tool_name, arguments)

        elapsed = time.time() - start_time
        logger.info(f"Tool {tool_name} completed in {elapsed:.2f}s")

        return result
```

**Caching Middleware:**
```python
from datetime import datetime, timedelta

_cache: dict[str, tuple[Any, datetime]] = {}
_cache_ttl = timedelta(minutes=5)

class CachingMiddleware(Middleware):
    async def on_call_tool(self, ctx, tool_name: str, arguments: dict):
        # Cache key
        cache_key = f"{tool_name}:{json.dumps(arguments, sort_keys=True)}"

        # Check cache
        if cache_key in _cache:
            result, timestamp = _cache[cache_key]
            if datetime.now() - timestamp < _cache_ttl:
                logger.debug(f"Cache HIT: {cache_key}")
                return result

        # Cache MISS
        result = await super().on_call_tool(ctx, tool_name, arguments)
        _cache[cache_key] = (result, datetime.now())

        return result
```

**Rate Limiting Middleware:**
```python
from collections import defaultdict
import asyncio

_rate_limits: dict[str, list[float]] = defaultdict(list)
_max_requests_per_minute = 60

class RateLimitMiddleware(Middleware):
    async def on_call_tool(self, ctx, tool_name: str, arguments: dict):
        client_id = ctx.request_id or "default"
        now = time.time()

        # Cleanup old requests
        _rate_limits[client_id] = [
            t for t in _rate_limits[client_id]
            if now - t < 60  # Last 60 seconds
        ]

        # Check rate limit
        if len(_rate_limits[client_id]) >= _max_requests_per_minute:
            raise Exception("Rate limit exceeded: 60 requests/minute")

        # Record request
        _rate_limits[client_id].append(now)

        return await super().on_call_tool(ctx, tool_name, arguments)
```

### 3. Pipeline Composition Ğ´Ğ»Ñ complex workflows

**ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½: Search â†’ Analyze â†’ Summarize**

```python
from src.pipelines import Pipeline

@mcp.tool(
    description="Research pipeline with AI analysis",
    tags={"research", "ai"}
)
async def research_pipeline(
    query: str,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Multi-step research workflow."""
    pipeline = Pipeline(ctx)

    results = await (
        pipeline
        .add_step(
            "search",
            pipeline_search_and_analyze,
            query=query,
            limit=10
        )
        .add_step(
            "analyze",
            pipeline_llm_analyze,
            # previous_results Ğ¿ĞµÑ€ĞµĞ´Ğ°ĞµÑ‚ÑÑ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸
        )
        .add_step(
            "summarize",
            pipeline_llm_summarize,
            # previous_results Ğ¿ĞµÑ€ĞµĞ´Ğ°ĞµÑ‚ÑÑ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸
        )
        .execute()
    )

    return {
        "query": query,
        "search_results": results["search"],
        "analysis": results["analyze"],
        "summary": results["summarize"]
    }
```

**Pipeline Step Implementation:**

```python
async def pipeline_search_and_analyze(
    query: str,
    limit: int = 10,
    ctx: Context | None = None,
    previous_results: dict | None = None
) -> dict[str, Any]:
    """Search R2R and return results."""
    if ctx:
        await ctx.info(f"Searching R2R: {query}")
        await ctx.report_progress(0, 100, "Searching...")

    response = await _client.post(
        "/v3/retrieval/search",
        json={
            "query": query,
            "limit": limit,
            "use_hybrid_search": True
        }
    )

    if ctx:
        await ctx.report_progress(100, 100, "Search completed")

    return response.json()

async def pipeline_llm_analyze(
    ctx: Context | None = None,
    previous_results: dict | None = None
) -> dict[str, Any]:
    """AI analysis of search results."""
    if not ctx:
        return {"error": "Context required for LLM sampling"}

    search_results = previous_results.get("search") if previous_results else {}

    await ctx.info("Analyzing search results with AI...")
    await ctx.report_progress(0, 100, "AI analysis...")

    # LLM sampling
    response = await ctx.sample(
        messages=[
            {"role": "user", "content": f"Analyze these search results and identify key themes: {json.dumps(search_results)}"}
        ],
        temperature=0.2
    )

    await ctx.report_progress(100, 100, "Analysis completed")

    try:
        analysis = json.loads(response.text)
    except json.JSONDecodeError:
        analysis = {"raw_response": response.text}

    return analysis

async def pipeline_llm_summarize(
    ctx: Context | None = None,
    previous_results: dict | None = None
) -> dict[str, Any]:
    """Executive summary of analysis."""
    if not ctx:
        return {"error": "Context required for LLM sampling"}

    analysis = previous_results.get("analyze") if previous_results else {}

    await ctx.info("Creating executive summary...")
    await ctx.report_progress(0, 100, "Summarizing...")

    response = await ctx.sample(
        messages=[
            {"role": "user", "content": f"Create an executive summary (2-3 sentences) of this analysis: {json.dumps(analysis)}"}
        ],
        temperature=0.3
    )

    await ctx.report_progress(100, 100, "Summary completed")

    return {
        "summary": response.text,
        "timestamp": datetime.now().isoformat()
    }
```

### 4. R2R Configuration Best Practices

**Environment Variables:**
```env
# R2R Backend
R2R_BASE_URL=http://localhost:7272
R2R_API_KEY=your_api_key_here
R2R_TIMEOUT=30.0

# FastMCP Server
FASTMCP_EXPERIMENTAL_ENABLE_NEW_OPENAPI_PARSER=true
DEBUG_LOGGING=false

# Optional: R2R OpenAPI spec URL
R2R_OPENAPI_URL=${R2R_BASE_URL}/openapi.json
```

**R2R Search Settings (default Ğ´Ğ»Ñ production):**
```json
{
  "use_hybrid_search": true,
  "search_strategy": "vanilla",
  "limit": 10,
  "chunk_settings": {
    "enabled": true,
    "index_measure": "cosine_distance"
  },
  "graph_settings": {
    "enabled": true
  },
  "hybrid_settings": {
    "full_text_weight": 1.0,
    "semantic_weight": 5.0,
    "rrf_k": 50
  }
}
```

**R2R Agent Settings (research mode):**
```json
{
  "mode": "research",
  "tools": ["rag", "reasoning", "critique", "python_executor"],
  "max_tokens": 4000,
  "temperature": 0.1,
  "thinking_budget": 4096
}
```

---

## âœ… Ğ—Ğ°ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ

### Ğ§Ñ‚Ğ¾ Ğ´Ğ°ĞµÑ‚ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ FastMCP + R2R?

**1. ĞŸĞ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ğ¾Ğµ RAG-Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ "Ğ¸Ğ· ĞºĞ¾Ñ€Ğ¾Ğ±ĞºĞ¸":**

```text
âœ… Document Management
   - Upload (FastMCP tool â†’ R2R POST /v3/documents)
   - Metadata (FastMCP resource â†’ R2R GET /v3/documents/{id})
   - Deletion (FastMCP tool â†’ R2R DELETE /v3/documents/{id})

âœ… Search & Retrieval
   - Semantic search (vector similarity)
   - Full-text search (keyword matching)
   - Hybrid search (combined scoring)
   - Graph search (entity relationships)

âœ… RAG Generation
   - Context-aware responses
   - Citation tracking
   - Streaming support
   - Multi-turn conversations

âœ… Knowledge Graph
   - Entity extraction
   - Relationship detection
   - Community detection
   - Graph-enhanced RAG (GraphRAG)

âœ… Agent Reasoning
   - Research mode (extended thinking)
   - Tool calling (Python executor, web search)
   - Multi-step reasoning
   - Critique and refinement

âœ… Multi-tenancy
   - Collections (organize documents)
   - User management
   - Access control

âœ… Production Features
   - Authentication (JWT/Bearer)
   - Middleware (logging, caching, rate limiting)
   - Error handling
   - Monitoring
   - Streaming
```

**2. Developer Experience:**

```python
# Minimal setup (30 minutes)
from fastmcp import FastMCP

mcp = FastMCP.from_openapi(
    spec_url="http://localhost:7272/openapi.json",
    auth=DynamicBearerAuth()
)

if __name__ == "__main__":
    mcp.run()
```

**3. Ğ“Ğ¸Ğ±ĞºĞ¾ÑÑ‚ÑŒ Ğ¸ Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼Ğ¾ÑÑ‚ÑŒ:**

```python
# Custom tools (Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ²Ğ¾Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºÑƒ)
@mcp.tool()
async def custom_search(query: str, ctx: Context) -> dict:
    # Custom pre-processing
    enhanced_query = preprocess(query)

    # R2R search
    results = await _client.post("/v3/retrieval/search", ...)

    # Custom post-processing
    return postprocess(results)

# Middleware (cross-cutting concerns)
mcp.add_middleware(LoggingMiddleware)
mcp.add_middleware(CachingMiddleware)
mcp.add_middleware(RateLimitMiddleware)

# Pipelines (complex workflows)
@mcp.tool()
async def research_pipeline(query: str, ctx: Context) -> dict:
    pipeline = Pipeline(ctx)
    return await pipeline.add_step(...).execute()
```

---

## ğŸ¯ Production Patterns

### Pattern 1: Auto-generated + Custom Tools

**ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°:** OpenAPI auto-generation Ğ´Ğ°ĞµÑ‚ Ğ±Ğ°Ğ·Ğ¾Ğ²ÑƒÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ, Ğ½Ğ¾ Ğ½ÑƒĞ¶Ğ½Ñ‹ enhanced tools.

**Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ:** ĞšĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ auto-generated Ğ¸ custom tools.

```python
# Auto-generate basic tools
mcp = FastMCP.from_openapi(
    spec_url="http://localhost:7272/openapi.json",
    route_maps=[...],
    auth=DynamicBearerAuth()
)

# Add custom enhanced tools
@mcp.tool(
    description="Enhanced search with AI analysis and progress reporting"
)
async def enhanced_search(
    query: str,
    limit: int = 10,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Search with progress and AI analysis."""
    # ... implementation ...

@mcp.tool(
    description="Research pipeline: search â†’ analyze â†’ summarize"
)
async def research_pipeline(
    query: str,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Multi-step research workflow."""
    # ... implementation ...
```

**Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚:**
- âœ… Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ tools Ğ¸Ğ· OpenAPI (Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾, Ğ±ĞµĞ· ĞºĞ¾Ğ´Ğ°)
- âœ… Enhanced tools Ñ Context (progress, logging, LLM sampling)
- âœ… Pipeline tools (complex workflows)

---

### Pattern 2: Resource Templates Ğ´Ğ»Ñ Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…

**ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°:** ĞÑƒĞ¶ĞµĞ½ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿ Ğº Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ğ¼ Ğ¿Ğ¾ ID Ñ‡ĞµÑ€ĞµĞ· Resources (Ğ½Ğµ Tools).

**Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ:** Resource Templates Ñ URI parameters.

```python
from fastmcp import ResourceTemplate

@mcp.resource_template(
    uri_template="r2r://documents/{document_id}",
    name="R2R Document",
    description="Get R2R document metadata by ID",
    annotations={"readOnlyHint": True}
)
async def r2r_document_resource(
    document_id: str,
    ctx: Context | None = None
) -> str:
    """Fetch document metadata from R2R."""
    if ctx:
        await ctx.info(f"Fetching document: {document_id}")

    try:
        response = await _client.get(f"/v3/documents/{document_id}")
        document = response.json()

        return json.dumps(document, indent=2)
    except Exception as e:
        if ctx:
            await ctx.error(f"Failed to fetch document: {e}")
        return json.dumps({"error": str(e)})
```

**Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ· LLM:**
```python
# LLM Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚ Ñ‡ĞµÑ€ĞµĞ· resource
content = await client.read_resource("r2r://documents/uuid-here")
```

---

### Pattern 3: Prompts Ğ´Ğ»Ñ reusable templates

**ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°:** ĞĞ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ²Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ¼Ğ¿Ñ‚Ñ‹ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‚ÑÑ Ğ² Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… tools.

**Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ:** Centralized prompt management.

```python
@mcp.prompt(
    name="rag_query_prompt",
    description="Structured prompt for RAG queries"
)
async def rag_query_prompt(query: str, context: str = "") -> list[dict]:
    """Generate structured RAG query prompt."""
    return [
        {
            "role": "system",
            "content": "You are a helpful assistant that answers questions based on provided context."
        },
        {
            "role": "user",
            "content": f"""Question: {query}

Context: {context}

Please provide a detailed, accurate answer based solely on the context provided."""
        }
    ]

@mcp.prompt(
    name="document_analysis_prompt",
    description="Analyze document content"
)
async def document_analysis_prompt(
    document: str,
    analysis_type: str = "summary"
) -> list[dict]:
    """Generate document analysis prompt."""
    prompts = {
        "summary": "Provide a concise summary of the document.",
        "entities": "Extract all key entities (people, organizations, locations).",
        "topics": "Identify main topics and themes.",
        "sentiment": "Analyze the sentiment and tone."
    }

    instruction = prompts.get(analysis_type, prompts["summary"])

    return [
        {
            "role": "user",
            "content": f"""Document:
{document}

Task: {instruction}"""
        }
    ]
```

**Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:**
```python
# LLM Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ prompt template
prompt = await client.get_prompt("rag_query_prompt", arguments={"query": "What is R2R?"})
```

---

### Pattern 4: Middleware Chaining

**ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°:** ĞÑƒĞ¶Ğ½Ğ¾ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ, ĞºÑÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ, rate limiting Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾.

**Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ:** Middleware chain (onion model).

```python
# Middleware order (execution order)
mcp.add_middleware(LoggingMiddleware)      # Outer layer
mcp.add_middleware(RateLimitMiddleware)    # Middle layer
mcp.add_middleware(CachingMiddleware)      # Inner layer

# Execution flow:
# Request
#   â†“
# LoggingMiddleware.on_request (before)
#   â†“
# RateLimitMiddleware.on_request (before)
#   â†“
# CachingMiddleware.on_request (before)
#   â†“
# Tool Execution
#   â†“
# CachingMiddleware.on_request (after)
#   â†“
# RateLimitMiddleware.on_request (after)
#   â†“
# LoggingMiddleware.on_request (after)
#   â†“
# Response
```

---

### Pattern 5: Conditional Pipelines

**ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğ°:** Workflow Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ñ‹Ñ… Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ².

**Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ:** ConditionalPipeline Ñ branches.

```python
from src.pipelines import ConditionalPipeline

@mcp.tool()
async def smart_search(
    query: str,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Smart search with conditional analysis."""
    pipeline = ConditionalPipeline(ctx)

    # Step 1: Search
    pipeline.add_step("search", pipeline_search_and_analyze, query=query)

    # Step 2: Conditional branch
    async def check_relevance(previous_results: dict) -> bool:
        """Check if results are relevant."""
        results = previous_results.get("search", {})
        # Check if top result score > 0.8
        return results.get("results", [{}])[0].get("score", 0) > 0.8

    # High relevance â†’ quick summary
    pipeline.add_conditional_step(
        "high_relevance_summary",
        pipeline_llm_summarize,
        condition=check_relevance
    )

    # Low relevance â†’ deep analysis
    pipeline.add_conditional_step(
        "low_relevance_analysis",
        pipeline_llm_analyze,
        condition=lambda r: not await check_relevance(r)
    )

    return await pipeline.execute()
```

---

## ğŸ’¡ ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñ‹

### Example 1: Minimal FastMCP + R2R Setup

**Ğ’Ñ€ĞµĞ¼Ñ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸:** 30 Ğ¼Ğ¸Ğ½ÑƒÑ‚

```python
"""Minimal FastMCP R2R Server - Auto-generated from OpenAPI."""
import os
from dotenv import load_dotenv
from fastmcp import FastMCP
import httpx

load_dotenv()

# Dynamic authentication (request-time)
class DynamicBearerAuth(httpx.Auth):
    def auth_flow(self, request: httpx.Request):
        api_key = os.getenv("R2R_API_KEY", "")
        if api_key:
            request.headers["Authorization"] = f"Bearer {api_key}"
        yield request

# Auto-generate MCP server from OpenAPI
mcp = FastMCP.from_openapi(
    name="R2R MCP Server",
    spec_url=os.getenv("R2R_OPENAPI_URL", "http://localhost:7272/openapi.json"),
    base_url=os.getenv("R2R_BASE_URL", "http://localhost:7272"),
    auth=DynamicBearerAuth()
)

if __name__ == "__main__":
    mcp.run()
```

**Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚:**
- âœ… 81 R2R endpoints â†’ 114 auto-generated MCP routes
- âœ… Resources Ğ´Ğ»Ñ GET endpoints (read-only data)
- âœ… Tools Ğ´Ğ»Ñ POST/PUT/DELETE (actions)

---

### Example 2: Enhanced Search Tool

**Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ AI Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ¸ progress reporting:**

```python
@mcp.tool(
    description="Enhanced search with AI analysis",
    tags={"search", "ai"}
)
async def enhanced_search(
    query: str,
    limit: int = 10,
    use_hybrid_search: bool = True,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Search R2R with progress and AI analysis."""
    if ctx:
        await ctx.info(f"Starting search: {query}")
        await ctx.report_progress(0, 100, "Searching R2R...")

    # R2R search
    response = await _client.post(
        "/v3/retrieval/search",
        json={
            "query": query,
            "limit": limit,
            "use_hybrid_search": use_hybrid_search,
            "search_strategy": "vanilla"
        }
    )

    results = response.json()

    if ctx:
        await ctx.report_progress(50, 100, "Analyzing results...")

        # AI analysis
        analysis = await ctx.sample(
            messages=[{
                "role": "user",
                "content": f"Analyze these search results and identify key themes: {json.dumps(results)}"
            }],
            temperature=0.2
        )

        await ctx.report_progress(100, 100, "Completed")

        return {
            "query": query,
            "results": results,
            "analysis": analysis.text
        }

    return results
```

---

### Example 3: Research Pipeline

**Multi-step workflow: Search â†’ Analyze â†’ Summarize**

```python
from src.pipelines import Pipeline

@mcp.tool(
    description="Research pipeline with AI analysis",
    tags={"research", "ai"}
)
async def research_pipeline(
    query: str,
    max_results: int = 10,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Multi-step research workflow."""
    pipeline = Pipeline(ctx)

    results = await (
        pipeline
        .add_step(
            "search",
            pipeline_search_and_analyze,
            query=query,
            limit=max_results
        )
        .add_step("analyze", pipeline_llm_analyze)
        .add_step("summarize", pipeline_llm_summarize)
        .execute()
    )

    return {
        "query": query,
        "timestamp": datetime.now().isoformat(),
        "search_results": results["search"],
        "analysis": results["analyze"],
        "summary": results["summarize"]
    }
```

**Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ· Claude:**
```bash
User: Research "machine learning best practices" in the knowledge base

Claude: Let me use the research pipeline...
[Calls research_pipeline tool]

Result:
- Found 10 relevant documents
- Key themes: model evaluation, data preprocessing, hyperparameter tuning
- Summary: Best practices include cross-validation, feature engineering,
          and proper train/test splitting.
```

---

### Example 4: Comparative Analysis Tool

**Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ğ´Ğ²ÑƒÑ… queries Ñ‡ĞµÑ€ĞµĞ· R2R:**

```python
@mcp.tool(
    description="Compare search results for two queries",
    tags={"comparison", "ai"}
)
async def comparative_analysis(
    query1: str,
    query2: str,
    limit: int = 5,
    ctx: Context | None = None
) -> dict[str, Any]:
    """Compare search results for two queries."""
    if ctx:
        await ctx.info(f"Comparing: '{query1}' vs '{query2}'")
        await ctx.report_progress(0, 100, "Searching...")

    # Search 1
    response1 = await _client.post(
        "/v3/retrieval/search",
        json={"query": query1, "limit": limit}
    )

    if ctx:
        await ctx.report_progress(30, 100, "First search completed")

    # Search 2
    response2 = await _client.post(
        "/v3/retrieval/search",
        json={"query": query2, "limit": limit}
    )

    if ctx:
        await ctx.report_progress(60, 100, "Both searches completed")

    results1 = response1.json()
    results2 = response2.json()

    if ctx:
        await ctx.report_progress(80, 100, "Analyzing differences...")

        # AI comparative analysis
        comparison = await ctx.sample(
            messages=[{
                "role": "user",
                "content": f"""Compare these two sets of search results:

Query 1: {query1}
Results 1: {json.dumps(results1)}

Query 2: {query2}
Results 2: {json.dumps(results2)}

Identify:
1. Overlapping documents
2. Unique aspects of each query
3. Key differences in retrieved content"""
            }],
            temperature=0.2
        )

        await ctx.report_progress(100, 100, "Analysis completed")

        return {
            "query1": query1,
            "query2": query2,
            "results1": results1,
            "results2": results2,
            "comparison": comparison.text
        }

    return {
        "query1": query1,
        "query2": query2,
        "results1": results1,
        "results2": results2
    }
```

---

## ğŸ“Š Ğ¡Ñ€Ğ°Ğ²Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·

### R2R vs FastMCP: ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‡Ñ‚Ğ¾?

| ĞšÑ€Ğ¸Ñ‚ĞµÑ€Ğ¸Ğ¹ | R2R | FastMCP | Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ñ |
|----------|-----|---------|--------------|
| **Document Ingestion** | âœ… Native | ğŸ”„ Proxy to R2R | Use R2R directly |
| **Search (semantic/hybrid)** | âœ… Native | ğŸ”„ Proxy to R2R | Use R2R via FastMCP tool |
| **RAG Generation** | âœ… Native | ğŸ”„ Proxy + enhance | Use R2R via FastMCP tool + ctx.sample |
| **Knowledge Graph** | âœ… Native | ğŸ”„ Proxy to R2R | Use R2R via FastMCP tool |
| **Agent Reasoning** | âœ… Native | ğŸ”„ Proxy + enhance | Use R2R agent OR FastMCP ctx.sample |
| **MCP Interface** | âŒ | âœ… Native | Use FastMCP |
| **LLM Tools/Resources** | âŒ | âœ… Native | Use FastMCP |
| **Middleware** | âŒ | âœ… Native | Use FastMCP |
| **Pipeline Composition** | âŒ | âœ… Native | Use FastMCP |
| **Progress Reporting** | âŒ | âœ… Native (Context) | Use FastMCP ctx.report_progress |
| **LLM Sampling in tools** | âŒ | âœ… Native (Context) | Use FastMCP ctx.sample |
| **Authentication** | âœ… JWT/Bearer | âœ… JWT/OAuth | Both (R2R: API, FastMCP: MCP) |
| **Caching** | âœ… Built-in | âœ… Middleware | Both (different layers) |
| **Deployment** | âœ… Docker/K8s | âœ… stdio/HTTP/Cloud | Both (different purposes) |

### ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ R2R?

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸:**
- ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ğ¹ REST API Ğ±ĞµĞ· LLM Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¸
- Backend Ğ´Ğ»Ñ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ĞµĞ³Ğ¾ frontend Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ
- Batch processing (ingestion, graph building)
- Analytics Ğ¸ reporting (Ğ¿Ñ€ÑĞ¼Ñ‹Ğµ SQL Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑ‹ Ğº PostgreSQL)

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€:**
```python
# ĞŸÑ€ÑĞ¼Ğ¾Ğ¹ Python SDK
from r2r import R2RClient

client = R2RClient("http://localhost:7272")

# Upload documents
client.documents.create(file=open("doc.pdf", "rb"))

# Search
results = client.retrieval.search(query="machine learning")

# RAG
answer = client.retrieval.rag(query="What is RAG?")
```

### ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ FastMCP + R2R?

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸:**
- LLM Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ (Claude Desktop, OpenAI, etc.)
- Autonomous agents Ñ tool calling
- Complex workflows (pipelines)
- Progress reporting Ğ´Ğ»Ñ UI
- AI-enhanced analysis (ctx.sample)
- Middleware requirements (logging, caching, rate limiting)

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€:**
```python
# FastMCP MCP Server
from fastmcp import FastMCP

mcp = FastMCP.from_openapi(
    spec_url="http://localhost:7272/openapi.json",
    auth=DynamicBearerAuth()
)

@mcp.tool()
async def enhanced_rag(query: str, ctx: Context) -> dict:
    # Progress reporting
    await ctx.report_progress(0, 100, "Searching...")

    # R2R RAG
    response = await _client.post("/v3/retrieval/rag", ...)

    await ctx.report_progress(50, 100, "Analyzing...")

    # AI enhancement
    analysis = await ctx.sample(...)

    await ctx.report_progress(100, 100, "Completed")

    return {"answer": response.json(), "analysis": analysis.text}
```

### ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ±Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾?

**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸:**
- R2R Ğ´Ğ»Ñ batch ingestion + FastMCP Ğ´Ğ»Ñ query/RAG
- R2R REST API Ğ´Ğ»Ñ frontend + FastMCP MCP Ğ´Ğ»Ñ LLM agents
- R2R analytics dashboard + FastMCP conversational interface

**ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°:**
```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”‚  LLM (Claude)  â”‚
â”‚   (React)      â”‚  REST  â”‚                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                         â”‚ MCP
         â”‚                         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   R2R REST API  â”‚       â”‚  FastMCP Server â”‚
â”‚   (Direct)      â”‚       â”‚  (MCP)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                         â”‚
         â”‚ HTTP                    â”‚ HTTP
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   R2R Backend   â”‚
         â”‚   (Shared)      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Ğ—Ğ°ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ

### ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ñ‹

1. **FastMCP Ğ¸ R2R - ĞºĞ¾Ğ¼Ğ¿Ğ»ĞµĞ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ½Ñ‹Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹:**
   - FastMCP: Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ´Ğ»Ñ LLM (MCP ÑĞµÑ€Ğ²ĞµÑ€)
   - R2R: Ğ”Ğ²Ğ¸Ğ¶Ğ¾Ğº Ğ´Ğ»Ñ RAG (Backend ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°)

2. **ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ğ°Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ:**
   - Ğ§ĞµÑ‚Ñ‹Ñ€ĞµÑ…ÑĞ»Ğ¾Ğ¹Ğ½Ğ°Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ (Presentation â†’ Business Logic â†’ Data Access â†’ R2R Backend)
   - OpenAPI auto-generation (REST API â†’ MCP components)
   - DynamicBearerAuth (request-time authentication Ğ´Ğ»Ñ serverless)

3. **Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼Ğ¾ÑÑ‚ÑŒ:**
   - R2R Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚: documents, search, RAG, knowledge graph, agent
   - FastMCP Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚: MCP interface, pipelines, middleware, Context

4. **ĞŸÑ€Ğ¾ÑÑ‚Ğ¾Ñ‚Ğ° Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ°:**
   - ĞœĞ¾Ğ´ÑƒĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´ (Phase 1 â†’ Phase 4)
   - ĞĞ¸Ğ·ĞºĞ¸Ğ¹ Ñ€Ğ¸ÑĞº (ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ phase Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼)
   - Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ğ¾Ñ‚Ğ´Ğ°Ñ‡Ğ° (minimal setup Ğ·Ğ° 30 Ğ¼Ğ¸Ğ½ÑƒÑ‚)

5. **Production-ready Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹:**
   - Auto-generated + custom tools
   - Resource templates Ğ´Ğ»Ñ dynamic data
   - Prompts Ğ´Ğ»Ñ reusable templates
   - Middleware chaining (logging, caching, rate limiting)
   - Pipeline composition (complex workflows)

6. **Ğ—Ğ°ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ:**
   - ĞŸĞ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ğ¾Ğµ RAG-Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğµ Ğ¸Ğ· ĞºĞ¾Ñ€Ğ¾Ğ±ĞºĞ¸
   - Ğ“Ğ¸Ğ±ĞºĞ¾ÑÑ‚ÑŒ Ğ¸ Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼Ğ¾ÑÑ‚ÑŒ
   - Production features (auth, monitoring, error handling)

### Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸

**Ğ”Ğ»Ñ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¾Ğ²:**
1. ĞĞ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ñ minimal FastMCP + R2R setup (30 Ğ¼Ğ¸Ğ½ÑƒÑ‚)
2. Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ custom enhanced tools Ğ¿Ğ¾ Ğ¼ĞµÑ€Ğµ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
3. Ğ’Ğ½ĞµĞ´Ñ€ÑĞ¹Ñ‚Ğµ middleware Ğ´Ğ»Ñ cross-cutting concerns
4. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ pipelines Ğ´Ğ»Ñ complex workflows

**Ğ”Ğ»Ñ Ğ¼Ğ¸Ğ³Ñ€Ğ°Ñ†Ğ¸Ğ¸:**
1. Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ R2R backend Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹
2. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ FastMCP ÑĞµÑ€Ğ²ĞµÑ€ Ñ OpenAPI auto-generation
3. ĞŸĞ¾ÑÑ‚ĞµĞ¿ĞµĞ½Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞ¹Ñ‚Ğµ enhanced tools Ğ¸ middleware
4. Ğ¢ĞµÑÑ‚Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¹ phase Ğ¿ĞµÑ€ĞµĞ´ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´Ğ¾Ğ¼ Ğº ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¼Ñƒ

**Ğ”Ğ»Ñ production:**
1. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ DynamicBearerAuth Ğ´Ğ»Ñ serverless compatibility
2. Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ middleware (logging, caching, rate limiting)
3. ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹Ñ‚Ğµ monitoring Ğ¸ alerting
4. ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€ÑƒĞ¹Ñ‚Ğµ search settings (hybrid search, vanilla strategy)
5. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ research mode Ğ´Ğ»Ñ complex queries

---

## ğŸ“š Ğ¡ÑÑ‹Ğ»ĞºĞ¸

### Ğ”Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸Ñ

- **FastMCP:** [gofastmcp.com](https://gofastmcp.com)
  - `docs/fastmcp/README.md` - ĞĞ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ hub (8 Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ¾Ğ²)
  - `docs/fastmcp/09-layered-architecture.md` - ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ñ‹Ğµ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹

- **R2R:** [r2r-docs.sciphi.ai](https://r2r-docs.sciphi.ai/)
  - `docs/r2r/README.md` - ĞĞ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹ hub (8 Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ¾Ğ²)
  - `docs/r2r/03-search-and-rag.md` - Search & RAG capabilities

- **Model Context Protocol:** [modelcontextprotocol.io](https://modelcontextprotocol.io)

### Production Code

- `src/server.py` - FastMCP R2R Server implementation
  - Lines 75-110: DynamicBearerAuth (CRITICAL for serverless)
  - Lines 121-145: Route mapping rules
  - Lines 328-519: Resource templates & Prompts
  - Lines 526-964: Enhanced tools & Pipeline tools

- `src/pipelines.py` - Pipeline patterns
  - Lines 28-160: ctx.sample patterns (7 types)
  - Lines 167-248: Pipeline base class
  - Lines 256-373: LLM-powered pipeline steps

### Configuration

- `.env.example` - Configuration template
- `.claude/config/.env` - R2R CLI credentials
- `openapi.json` - R2R OpenAPI 3.1 spec

---

**Ğ’ĞµÑ€ÑĞ¸Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°:** 1.0
**ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½ĞµĞµ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ:** 2025-11-27
**ĞĞ²Ñ‚Ğ¾Ñ€Ñ‹:** Based on R2R Agent analysis + FastMCP/R2R documentation + Production code examples
